/*
 * Test HMAC-SHA1.
 *
 * Copyright (C) 2014 Allwinner.
 *
 * Mintow <duanmintao@allwinnertech.com>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2.  This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 *
 * 2014-09-16, mintow, create.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <openssl/engine.h>
#include <openssl/sha.h>
#include <openssl/hmac.h>

#include "ss_test.h"

struct af_alg_digest_data
{
	char key[SHA_CBLOCK];
	int keylen;
};

static struct test_st {
	char key[128];
	int key_len;
	char data[128];
	int data_len;
	unsigned char *digest;
} test[] = {
	{	"",
		0,
		"More text test vectors to stuff up EBCDIC machines :-)",
		54,
		(unsigned char *)"b760e92d6662d351eb3801057695ac0346295356",
	},{	"Jefe",
		4,
		"what do ya want for nothing?",
		28,
		(unsigned char *)"effcdf6ae5eb2fa2d27416d5f184df9c259a7c79",
	},{
		{0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
		 0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,},
		16,
		{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd},
		50,
		(unsigned char *)"d730594d167e35d5956fd8003d0db3d3f46dc7bb",
	}, {
		{0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
		 0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
		 0xaa,0xaa,0xaa,0xaa},
		20,
		{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd},
		56,
		(unsigned char *)"09a13335188749ec35ce0dd46185eb6c65719cf2",
	}, {
		{0x01,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x02,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x03,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x04,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x05,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x06,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x07,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x08,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x09},
		65,
		{0xd1,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd2,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd3,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd4,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd5,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd6,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd7,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd8,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd9,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xda,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd},
		80,
		(unsigned char *)"5422e0af0382e0384f2500f0527d92b7bd3d67c8",
	},
};

static  void hmac_sha1_dump(char *str,unsigned char *data,\
	int len,int align)
{
	int i = 0;
	if(str)
		printf("\n%s: ",str);
	for(i = 0;i<len;i++)
	{
		if((i%align) == 0)
		{
			printf("\n");
		}
		printf("%x",*(data++));
	}
	printf("\n");
}


static unsigned char md[SHA_DIGEST_LENGTH];

static ENGINE *openssl_engine_init(char *type)
{
	ENGINE *e = NULL;
	const char *name = "af_alg";

	OpenSSL_add_all_algorithms();
	ENGINE_load_builtin_engines();

	e = ENGINE_by_id(name);
	if (!e) {
		DBG("find engine %s error\n", name);
		return NULL;
	}

	ENGINE_ctrl_cmd_string(e, "DIGESTS", type, 0);
	return e;
}

static void openssl_engine_free(ENGINE *e)
{
	if (e != NULL)
		ENGINE_free(e);

	ENGINE_cleanup();
	EVP_cleanup();
}

static char *pt(unsigned char *md)
{
	int i;
	static char buf[80] = {0};

	for (i=0; i<SHA_DIGEST_LENGTH; i++)
		sprintf(&(buf[i*2]),"%02x",md[i]);
	return(buf);
}

int check_key(char *dst, char *src, int len)
{
	memset(dst, 0, SHA_CBLOCK);
	if (len <= SHA_CBLOCK) {
		memcpy(dst, src, len);
		return len;
	}

	/* Get the hash value of src. */
	EVP_Digest(src, len, (unsigned char *)dst, NULL, EVP_sha1(), NULL);
	return SHA_DIGEST_LENGTH;
}
#define CE_TEST_PREFIX "CE_HMAC_SHA1:"
int hmac_sha1_entry(int argc, char *argv[])
{
	int ret = 0;
	unsigned int i = 0;
	char *p = NULL;

	ENGINE *e = NULL;
	EVP_MD_CTX ctx = {0};
	const EVP_MD *e_md = NULL;
	struct af_alg_digest_data *ddata = NULL;

	e = openssl_engine_init("hmac-sha1");
	if (e == NULL) {
		return -1;
	}
	for(i = 0; i < 4; i++)
	{
		e_md = ENGINE_get_digest(e, NID_hmac_sha1);
		if (e_md == NULL) {
			DBG("ENGINE_get_digest() failed! \n");
			ret = -1;
			goto error;
		}

		EVP_DigestInit(&ctx, e_md);

		ddata = (struct af_alg_digest_data *)ctx.md_data;
		ddata->keylen = check_key(ddata->key, test[i].key, test[i].key_len);

		hmac_sha1_dump("key data", (unsigned char*)ddata->key,
		ddata->keylen, 16);

		EVP_DigestUpdate(&ctx, test[i].data, (unsigned long)test[i].data_len);
		EVP_DigestFinal(&ctx, md, NULL);

		p = pt(md);
		if (strcmp(p, (char *)test[i].digest) != 0) {
			printf("\n%s test item%d failed!\n", CE_TEST_PREFIX, i);
			printf("\tActual: %s \n\tExpect: %s\n", p, test[i].digest);
			ret = 1;
		}
		else
			printf("\n%s test item%d ok\n", CE_TEST_PREFIX, i);

		EVP_MD_CTX_cleanup(&ctx);
	}
error:
	openssl_engine_free(e);
	return ret;
}

