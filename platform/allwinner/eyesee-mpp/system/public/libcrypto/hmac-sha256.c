/*
 * Test HMAC-SHA256.
 *
 * Copyright (C) 2014 Allwinner.
 *
 * Mintow <duanmintao@allwinnertech.com>
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2.  This program is licensed "as is" without any
 * warranty of any kind, whether express or implied.
 *
 * 2014-09-16, mintow, create.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <openssl/engine.h>
#include <openssl/sha.h>
#include <openssl/hmac.h>

#include "ss_test.h"

struct af_alg_digest_data
{
	char key[SHA_CBLOCK];
	int keylen;
};

static struct test_st {
	char key[128];
	int key_len;
	char data[128];
	int data_len;
	unsigned char *digest;
} test[] = {
	{	"",
		0,
		"More text test vectors to stuff up EBCDIC machines :-)",
		54,
		(unsigned char *)"5a3f9959ce1f220eadeb40e4d89b3b8d3ea10e1b6917b5c4bb131624eb740b8e",
	},{	"Jefe",
		4,
		"what do ya want for nothing?",
		28,
		(unsigned char *)"5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843",
	},{
		{0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
		 0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,},
		16,
		{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd},
		50,
		(unsigned char *)"7dda3cc169743a6484649f94f0eda0f9f2ff496a9733fb796ed5adb40a44c3c1",
	}, {
		{0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
		 0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
		 0xaa,0xaa,0xaa,0xaa},
		20,
		{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd},
		56,
		(unsigned char *)"84b80c64bc87c9824304ff1066d0fa1c37787428b8a2e3e37838a3b713947d4a",
	}, {
		{0x01,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x02,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x03,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x04,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x05,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x06,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x07,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x08,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
		 0x09},
		65,
		{0xd1,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd2,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd3,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd4,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd5,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd6,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd7,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd8,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xd9,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,
		 0xda,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd},
		80,
		(unsigned char *)"73b0aeb1f519311ec0e53738e9aa10a59f7eb9be89a9887092103d22307b49ac",
	},
};
static unsigned char md[SHA256_DIGEST_LENGTH];
static ENGINE *openssl_engine_init(char *type)
{
	ENGINE *e = NULL;
	const char *name = "af_alg";

	OpenSSL_add_all_algorithms();
	ENGINE_load_builtin_engines();

	e = ENGINE_by_id(name);
	if (!e) {
		DBG("find engine %s error\n", name);
		return NULL;
	}

	ENGINE_ctrl_cmd_string(e, "DIGESTS", type, 0);
	return e;
}

static void openssl_engine_free(ENGINE *e)
{
	if (e != NULL)
		ENGINE_free(e);

	ENGINE_cleanup();
	EVP_cleanup();
}

static char *pt(unsigned char *md)
{
	int i;
	static char buf[80] = {0};

	for (i=0; i<SHA256_DIGEST_LENGTH; i++)
		sprintf(&(buf[i*2]),"%02x",md[i]);
	return(buf);
}

static int check_key(char *dst, char *src, int len)
{
	memset(dst, 0, SHA_CBLOCK);
	if (len <= SHA_CBLOCK) {
		memcpy(dst, src, len);
		return len;
	}
	else
	{
		EVP_Digest(src, len, (unsigned char *)dst, NULL, EVP_sha256(), NULL);
		return SHA256_DIGEST_LENGTH;
	}
}

#define CE_TEST_PREFIX "CE_HMAC_SHA256:"
int hmac_sha256_entry(int argc, char *argv[])
{
	int ret = 0;
	unsigned int i = 1;
	char *p = NULL;

	ENGINE *e = NULL;
	EVP_MD_CTX ctx = {0};
	const EVP_MD *e_md = NULL;
	struct af_alg_digest_data *ddata = NULL;

	e = openssl_engine_init("hmac-sha256");
	if (e == NULL) {
		return -1;
	}

	for(i = 0; i < 4; i++)
	{
		e_md = ENGINE_get_digest(e, NID_hmacWithSHA256);
		if (e_md == NULL) {
			DBG("ENGINE_get_digest() failed! \n");
			ret = -1;
			goto error;
		}
		EVP_DigestInit(&ctx, e_md);
		/*ddata->keylen is not used aw hardware restriction:key_len must equal 64B*/
		/*ref:af_alg_hmac_sha_update : ALG_SET_KEY*/
		ddata = (struct af_alg_digest_data *)ctx.md_data;
		ddata->keylen = check_key(ddata->key, test[i].key, test[i].key_len);
		EVP_DigestUpdate(&ctx, test[i].data, (unsigned long)test[i].data_len);
		EVP_DigestFinal(&ctx, md, NULL);
		p = pt(md);
		if (strcmp(p, (char *)test[i].digest) != 0) {
			printf("\n%s test item%d failed!\n", CE_TEST_PREFIX, i);
			printf("\tActual: %s \n\tExpect: %s\n", p, test[i].digest);
			ret = -1;
		}
		else
			printf("\n%s test item%d ok\n", CE_TEST_PREFIX, i);
		EVP_MD_CTX_cleanup(&ctx);
	}
error:
	openssl_engine_free(e);
	return ret;
}

